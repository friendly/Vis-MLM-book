```{r include=FALSE}
source("R/common.R")
```

# Preface {.unnumbered}

## ONE, TWO, MANY

There is an old and helpful idea I learned from John Hartigan in my graduate days at Princeton:

> In statistics and data visualization *all* methods can be classified by the number of dimensions contemplated, on a scale of **ONE**, **TWO**, **MANY**.

By this, he meant that, at a global level, all data, statistical summaries, and graphical displays could be classified as:

-   **univariate**: a single variable, considered in isolation (age, COVID cases, pizzas ordered). Univariate numerical summaries are means, medians, measures of variablilty, and so forth. Univariate displays include dot plots, boxplots, histograms and density estimates.
-   **bivariate**: two variables, considered jointly. Numerical summaries include correlations, covariances and two-way tables of frequencies or measures of association for categorical variables. Bivariate displays include scatterplots and mosaic plots.
-   **multivariate**: three or more variables, considered jointly. Numerical summaries include correlation and covariance matrices, consisting of all pairwise values, but also derived measures from the analysis of these matrices (eigenvalues, eigenvectors). Graphical displays of multivariate data can sometimes be shown in
3D, but often involve multiple views of the data projected into 2D plots.

As a quasi-numerical scale, I refer to these as **1D**, **2D** and **nD**. This admits the possibility of half-integer cases, such as 1.5D, where the main focus is on a single variable, but it is classified by a simple factor (gender). His point in this classification was that once you reached three variables, all higher dimensions involved similar summaries and data displays.

Univariate and bivariate methods and displays are well-known.  This book is about how these ideas can
be extended to an $n$-dimensional world. Three-dimensional data displays are now fairly easy to produce,
even if they are sometimes difficult to understand. But how can we even think about four or more dimensions?
The difficulty can be appreciated by considering the tale of _Flatland_.

```{r child="flatland.qmd"}
```

## EUREKA!

Even modest sized multivariate data can have secrets that can be revealed in the right view.
As an example, David Coleman at RCA Laboratories in Princeton, N.J. generated a data set of
five (fictitious) measurements of grains of pollen for the 1986 Data Exposition at the
Joint statistical Meetings.
The first three variables are the lengths of geometric features 3848 observed sampled pollen grains -- in the x, y, and z dimensions: a `ridge` along x, a `nub` in the y
direction, and a `crack` in along the z dimension.  The fourth
variable is pollen grain `weight`, and the fifth is `density`.
The challenge was to "find something interesting" in this data set.

Those who solved the puzzle were able to find an orientation of this 5-dimensional data set, such that
zooming in revealed a magic word, "EUREKA" spelled in points, as in the following figure.

::: {#fig-pollen-eureka layout-nrow=2}
![](images/pollen-eureka1.png){width=40%}

![](images/pollen-eureka2.png){width=40%}

![](images/pollen-eureka4.png){width=40%}

![](images/pollen-eureka3.png){width=40%}

Four views of the `pollen` data, zooming in, clockwise from the upper left to discover the word "EUREKA".

:::

This can be seen better in a 3D animation. `rgl` is used to create a 3D scatterplot of the first three
variables. Then the `animation` package is use to record a sequence of images, adjusting the
`rgl::par3d(zoom)` value.

```{r}
#| label: pollen-eureka-code
#| eval: false
library(animation)
library(rgl)
data(pollen, package = "animation")
oopt = ani.options(interval = 0.05)
## adjust the viewpoint
uM =
  matrix(c(-0.370919227600098, -0.513357102870941,
           -0.773877620697021, 0, -0.73050606250763, 0.675815105438232,
           -0.0981751680374146, 0, 0.573396027088165, 0.528906404972076,
           -0.625681936740875, 0, 0, 0, 0, 1), 4, 4)
open3d(userMatrix = uM, 
       windowRect = c(10, 10, 510, 510))

plot3d(pollen[, 1:3])

# zoom in
zm = seq(1, 0.045, length = 200)
par3d(zoom = 1)
for (i in 1:length(zm)) {
  par3d(zoom = zm[i])
  ani.pause()
}
ani.options(oopt)
```


::: {#fig-pollen-eureka-fig}

<iframe width="560" height="315" src="images/pollen-eureka.gif"></iframe>

Animation of zooming in on the `pollen` data.
:::

## What I assume

I assume the reader to have at least a basic familiarity with R.
While R fundamentals are outside the scope of the current paper, I believe that this language provides a rich set of resources, far beyond that offered by other statistical software packages, and is well worth learning. 

For those not familiar with R, I recommend @Matloff2011, @Wickham2014, and @Cotton2013 for introductions to programming in the language, and @FoxWeisberg:2018 and @Teetor2011 for learning about how to conduct basic statistical analyses. 



## Conventions

## References {.unnumbered}
