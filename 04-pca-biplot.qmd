```{r include=FALSE}
source(here::here("R", "common.R"))
```

# PCA and Biplots {#sec-pca-biplot}

## _Flatland_ and _Spaceland_ {#sec-spaceland}

> It is high time that I should pass from these brief and discursive notes about Flatland to the central event of this book, my initiation into the mysteries of Space. THAT is my subject; all that has gone before is merely preface --- Edwin Abbott, _Flatland_, p. 57.

There was a cloud in the sky above _Flatland_ one day. But it was a huge, multidimensional cloud of sparkly points that might contain some important message, perhaps like the hidden EUREKA (@fig-pollen-eureka-fig), or perhaps forecasting the upcoming harvest, if only Flatlanders could appreciate it. 

A leading citizen, A SQUARE, who had traveled once to 
Spaceland and therefore had an inkling of its majesty beyond the simple world of his life in the plane looked at that cloud and had a brilliant thought, an OMG moment:

> "Oh, can I, in my imagination, rotate that cloud and squeeze its' juice so that it rains down on Flatland with greatest joy?"

As it happened, our Square friend, although he could never really _see_ in three dimensions, he could now 
at least _think_ of a world described by **height** as well as breadth and width, and think of the
**shadow** cast by a cloud as something mutable, changing size and shape depending on its' orientation over Flatland.

And what a world it was, inhabited by
Pryamids, Cubes and wondrous creatures called Polyhedrons with many $C$orners, $F$aces and $E$dges.
Not only that, but all those Polyhedra were forced in Spaceland to obey a magic formula:
$C + F - E = 2$.[^1-euler] How cool was that!

[^1-euler]: This is Euler's [-@Euler:1758] formula, which states that any convex polyheron must obey the formula $V + F - E = 2$ where $V$ is the number of vertexes (corners), $F$ is the number of faces and $E$ is the number of edges.  For example, a tetrahedron
or pyramid has $(V, F, E) = (4, 4, 6)$ and a cube has $(V, F, E) = (8, 6, 12)$. Stated in words,
for all solid bodies confined by planes, the sum of the number of vertexes and the number of faces is two less than the number of edges.

Indeed, there were even exalted Spheres,
having so many faces that its surface became as smooth as a baby's bottom with no need for pointed corners or edges, just as Circles were the smoothest occupants of his world with far too many sides to count.
It was his dream of a Sphere passing through Flatland (@fig-flatland-spheres) that first awakened him to 
a third dimension.

He also marveled at Ellipsoids, as smooth as Spheres, but in Spaceland having three natural axes of different extent
and capable of being appearing fatter or slimmer when rotated from different views. An Ellipsoid
had magical properties: it could appear as so thin in one or more dimensions that it became a simple
2D ellipse, or a 1D line, or even a 0D point [@Friendly-etal:ellipses:2013].
<!-- **TODO**: somehow mention the `gellipsoid` package here. -->

All of these now arose in Square's richer 3D imagination. 
And, all of this came from just one more dimension than his life in Flatland.


### Multivariate juicers

Up to now, we have also been living in Flatland. We have been trying to understand data in
**data space** of possibly many dimensions, but confined to the 2D plane of a graph window.
Scatterplot matrices and parallel coordinate plots provided some relief. 
The former did so by **projecting** the data into sets of 2D views in the coordinates of data
space; the latter did so by providing multiple axes in a 2D space along which we could trace
the paths of individual observations.

This chapter is about seeing data in a different projection, a low-dimensional, usually 2D, space
that which squeezes out the most juice
from multidimensional data for a particular purpose (@fig-MV-juicer), where what we want to
understand can be more easily seen.

```{r}
#| label: fig-MV-juicer
#| echo: false
#| fig-align: center
#| out-width: "90%"
#| fig-cap: "A multivariate juicer takes data from possibly high-dimensional data space and transforms it to a lower-dimenional space in which important effects can be more easily seen."
knitr::include_graphics("images/MV-juicer.png")
```

Here, I concentrate on **principal components analysis** (PCA), whose goal reflects A Square's desire to see that sparkly cloud of points 
in $nD$ space in the plane showing the greatest variation (squeezing the most juice)
among all other possible views.
This appealed to his sense of geometry, but left him wondering how the variables in that 
high-D cloud were related to the dimensions he could see in a best-fitting plane.

The idea of a **biplot**, showing the data points in the plane, together with thick pointed
arrows---variable vectors--- in one view is the other topic explained in this chapter (@sec-biplot). The biplot is the simplest example of a multivariate juicer. The essential idea is to project the cloud of data points in $n$ dimensions into the 
2D space of principal components and simultaneously show how the original variables
relate to this space. For exploratory analysis to get an initial, incisive view of
a multivariate dataset, a biplot is often my first choice.

::: callout-note
## Looking ahead
I'm using the term _multivariate juicer_ here to refer the wider class of **dimension reduction** techniques,  used for various purposes in data analysis and visualization and principal components analysis is the simplest example.

The key point is that these methods are designed to transform the data into a low-dimensional space for a particular goal or purpose. In PCA, the goal is to extract the greatest amount of total variability in the data. In the context of univariate multiple regression, the goal is often to reduce the number of predictors necessary to account for an outcome variable, called _feature selection_ in the machine learning literature.

When the goal is to best distinguish among groups ...

...

:::

**Packages**

In this chapter I use the following packages. Load them now:

```{r load-pkgs}
library(ggplot2)
library(dplyr)
library(tidyr)
library(patchwork)
library(ggbiplot)
```


## Principal components analysis {#sec-pca}

When Francis Galton [-@Galton:1886] first discovered the idea of regression toward the mean
and presented his famous diagram (@fig-galton-corr), he had little thought that he had provided a
window to a higher-dimensional world, beyond what even A Square could imagine. 
His friend, Karl Pearson [-@Pearson:1896] took that idea and developed it into a theory of
regression and a measure of correlation that would bear his name, Pearson's $r$.

But then Pearson [-@Pearson:1901] had a further inspiration, akin to that of A Square. 
If he also had a cloud of sparkly points in $2, 3, 4, ..., p$ dimensions, could he find a
point ($0D$), or line ($1D$), or plane ($2D$), or even a hyperplane ($nD$) that best summarized ---
squeezed out the most juice---from multivariate data? This was the first trully multivariate
problem in the history of statistics [@FriendlyWainer:2021:TOGS, p. 186].

The best $0D$ point was easy--- it was simply the centroid, the means of each of the
variables in the data, $(\bar{x}_1, \bar{x}_2, ..., \bar{x}_p)$, because that was "closest"
to the data in the sense of minimizing the sum of squared differences, $\Sigma_i\Sigma_j (x_{ij} - \bar{x}_j)^2$.
In higher dimensions, his solution was also an application of the method of least squares, but he argued
it geometrically and visually as shown in @fig-Pearson1901.

```{r}
#| label: fig-Pearson1901
#| echo: false
#| fig-align: center
#| out-width: "70%"
#| fig-cap: "Karl Pearson's (1901) geometric, visual argument for finding the line or plane of closest fit to a collection of points, P1, P2, P3, ... "
knitr::include_graphics("images/Pearson1901.png")
```

For a $1D$ summary, the line of best fit to the points $P_1, P_2, \dots P_n$ is the line that goes through the
centroid and made the average squared length of the _perpendicular_ segments from those points to a line as small
as possible. This was different from the case in linear regression, for fitting $y$ from $x$,
where the average squared length of the _vertical_ segments, $\Sigma_i (y_i - \hat{y}_i)^2$ was minimized by
least squares.

He went on to prove the visual insights from simple smoothing of @Galton:1886 (shown in @fig-galton-corr) 
regarding the regression lines of
`y ~ x` and `x ~ y`. More importantly, he proved that the cloud of points is captured,
for the purpose of finding a best line, plane or hyperplane, by
the ellipsoid that encloses it, as seen in his diagram, @fig-Pearson1901-2. The major axis of the 
2D ellipse is the line of best fit, along which the data points have the smallest average squared
distance from the line. The axis at right angles to that---the minor axis--- is labeled "line of worst fit"
with the largest average squared distance.

```{r}
#| label: fig-Pearson1901-2
#| echo: false
#| fig-align: center
#| out-width: "80%"
#| fig-cap: "Karl Pearson's diagram showing the elliptical geometry of regression and principal components analysis ... _Source_: Pearson (1901), p. 566."
knitr::include_graphics("images/Pearson1901_2.png")
```

Even more importantly--- and this is the basis for what we call **principal components analysis** (PCA)--- he recognized that the two orthogonal axes of the ellipse gave new coordinates for the data which were uncorrelated, whatever the correlation of $x$ and $y$.

> Physically, the axes of the correlation type-ellipse are the directions of independent and uncorrelated variation. --- @Pearson:1901, p. 566.

It was but a small step to recognize that for two variables, $x$ and $y$:

* the line of best fit, the major axis (PC1) had the greatest variance of points projected onto it;
* the line of worst fit, the minor axis (PC2), had the least variance;
* these could be seen as a rotation of the data space of $(x, y)$ to a new space (PC1, PC2) with uncorrelated variables;
* the total variation of the points in data space, $\text{Var}(x) + \text{Var}(y)$, being unchanged by rotation, was equally well expressed as the total variation $\text{Var}(PC1) + \text{Var}(PC2)$ of the scores on what are
now called the principal component axes.

It would have appealed to Pearson (and also to A Square) to see these observations demonstrated in a 3D video. @fig-pca-animation
shows a 3D plot of the variables `Sepal.Length`, `Sepal.Width` and `Petal.Length` in Edgar Anderson's `iris`
data, with points colored by species and the 95% data ellipsoid. This is rotated smoothly by interpolation until the first two principal axes, PC1 and PC2 are aligned with the horizontal and vertical dimensions. 
Because this is a rigid rotation of the cloud of points, the total variability is obviously unchanged.


<!-- ::: {#fig-pca-animation} -->
<!-- <div align="center"> -->
<!-- <iframe width="946" height="594" src="images/pca-animation1.gif"></iframe> -->
<!-- </div> -->
<!-- Animation of PCA as a rotation in 3D space. The plot shows three variables for the `iris` data, initially -->
<!-- in data space and its' data ellipsoid, with points colored according to species of the iris flowers. This is rotated smoothly until the first two principal axes are aligned with the horizontal and vertical dimensions. -->

<!-- ::: -->

::: {.content-visible unless-format="pdf"}
```{r}
#| label: fig-pca-animation
#| out-width: "100%"
#| echo: false
#| fig-cap: "Animation of PCA as a rotation in 3D space. The plot shows three variables for the #| `iris` data, initially in data space and its' data ellipsoid, with points colored according #| to species of the iris flowers. This is rotated smoothly until the first two principal axes #| are aligned with the horizontal and vertical dimensions."
knitr::include_graphics("images/pca-animation1.gif")
```
:::



### PCA by springs

Before delving into the mathematics of PCA, it is useful to see how Pearson's problem, and fitting by least squares generally, could be solved in a physical realization. 

From elementary statistics, you may be familiar with a
physical demonstration that the mean, $\bar{x}$, of a sample is the value for which the sum of deviations,
$\Sigma_i (x_i - \bar{x})$ is zero, so the mean can be visualized as the point of balance on a line where
those differences $(x_i - \bar{x})$ are placed. Equally well, there is a physical realization of the mean
as the point along an axis where weights connected by springs will minimize the sum of squared differences,
because springs with a constant stiffness, $k$, exert forces proportional to $k (x_i - \bar{x}) ^2$. That's
the reason is useful as a measure of central tendency: it minimizes the average squared error.

In two dimensions, imagine that we have points, $(x_i, y_i)$ and these are attached by springs of equal stiffness $k$, to a line anchored at the centroid, $(\bar{x}, \bar{y})$ as shown in @fig-pca-springs. 
If we rotate the line to some initial position and release it, the springs will pull the line clockwise or counterclockwise and the line will bounce around until the forces, proportional to the squares of the lengths of the springs, will eventually balance out at the position 
(shown by the `r colorize("red")` fixed line segments at the ends). This is the position that minimizes the
the sum of squared lengths of the connecting springs, and also minimizes the kinetic energy in the system.

If you look closely at @fig-pca-springs you will see something else: When the line is at its' final position of minimum
squared length and energy, the positions of the `r colorize("red")` points on this line are spread out furthest, i.e., have **maximum** variance. Conversely, when the line line is at right angles to its' final position (shown by the black line at 90$^o$) the projected points have the smallest possible variance.

::: {#fig-pca-springs}
<div align="center">
<iframe width="412" height="364" src="images/pca-springs-cropped.gif"></iframe>
</div>
Animation of PCA fitted by springs. The `r colorize("blue")` data points are connected to their projections on the `r colorize("red")` line by springs perpendicular to that line. From an initial position, the springs pull that line in proportion to their squared distances, until the line finally settles down to the position where the forces are balanced and the minimum is achieved. _Source_: Amoeba, https://bit.ly/46tAicu.

:::

<!-- See: https://joshualoftus.com/posts/2020-11-23-least-squares-as-springs/least-squares-as-springs.html -->

**TODO**: Simple PCA example using workers data

### Mathematics and geometry of PCA

As the ideas of principal components developed, there was a happy marriage of Galton's geometrical intuition and Pearson's mathematical analysis. The best men at the wedding were ellipses and
higher-dimensional ellipsoids. The brides maids were eigenvectors, pointing in as many
different directions as space would allow, each sized according to their associated eigenvalues.
Attending the wedding were the ghosts of uncles, Leonhard Euler, Jean-Louis Lagrange,
Augustin-Louis Cauchy and others who had earlier discovered the mathematical properties
of quadratic forms in relation to problems in physics.

The key idea in the statistical application was that, for a set of variables $\mathbf{x}_1, \mathbf{x}_2, \dots, \mathbf{x}_p$,
the $p \times p$ covariance matrix $\mathbf{S}$ could be expressed exactly as a matrix
product involving a matrix $\mathbf{V}$, whose columns are eigenvectors ($\mathbf{v}_i$) and a
diagonal matrix $\mathbf{\Lambda}$, whose diagonal elements ($\lambda_i$) are the corresponding eigenvalues,

$$
\begin{align*}
\mathbf{S} & = \mathbf{V} \mathbf{\Lambda} \mathbf{V}^T \\
           & = \lambda_1 \mathbf{v}_1 \mathbf{v}_1^T + \lambda_2 \mathbf{v}_2 \mathbf{v}_2^T + ... + \lambda_p \mathbf{v}_p \mathbf{v}_p^T
\end{align*}
$$
In this equation,
* The columns of $\mathbf{V}$ are the eigenvectors and they represent orthogonal (uncorrelated) directions in data space. The values $\mathbf{v}_i$ are the weights applied to the variables.
* The eigenvalues, $\lambda_i$ ...

For the case of two variables, $\mathbf{x}_1$ and $\mathbf{x}_2$ @fig-pca-rotation shows the
transformation ...
```{r}
#| label: fig-pca-rotation
#| out-width: "100%"
#| echo: false
#| fig-cap: "Geometry of PCA as a rotation from data space to principal component space, defined by the eigenvectors v1 and v2 of a covariance matrix"
 knitr::include_graphics("images/pca-rotation.png")
```


### Finding principal components

In R, principal components analysis is most easily carried out using `stats::prcomp()` or `stats::princomp()`
or similar functions in other packages such as `FactomineR::PCA()`.
The **FactoMineR** package [@R-FactoMineR] 
has extensive capabilities for exploratory analysis of multivariate data (PCA, correspondence analysis, cluster analysis, ...). 

Unfortunately, although all of these performing similar calculations, the options for
analysis and the details of the result they return differ.

The important options for analysis include: 

* whether or not the data variables are **centered**, to a mean of $\bar{x}_j =0$
* whether or not the data variables are **scaled**, to a variance of $\text{Var}(x_j) =1$.

It nearly always makes sense to center the variables. The choice of
scaling determines whether the correlation matrix is analyzed, so that
each variable contributes equally to the total variance that is to be accounted for
versus analysis of the covariance matrix, where each variable contributes its
own variance to the total. Analysis of the covariance matrix makes little sense
when the variables are measured on different scales.[^pca-scales]

[^pca-scales]: For example, if two variables in the analysis are height and weight, changing the unit of height from inches to centimeters would multiply its' variance by $2.54^2$; changing weight from pounds to kilograms would divide its' variance by $2.2^2$.

#### Example: Crime data {.unnumbered}

The dataset `crime`, analysed in @sec-corrgram, showed all positive correlations among the rates of various
crimes in the corrgram, @fig-crime-corrplot. What can we see from a principal components analysis?
Is it possible that a few dimensions can account for most of the juice in this data?

In this example, you can easily find the PCA solution using `prcomp()` in a single line in base-R.
You need to specify the numeric variables to analyze by their columns in the data frame.
The most important option here is `scale. = TRUE` ...

```{r crime-pca0}
data(crime, package = "ggbiplot")
crime.pca <- prcomp(crime[, 2:7], scale. = TRUE)
```

The tidy equivalent is more verbose, but also more expressive about what is being done.
It selects the variables to analyze by a function, `is.numeric()` applied to each of the columns and feeds
the result to `prcomp()`.
```{r crime-pca}
crime.pca <- 
  crime |> 
  dplyr::select(where(is.numeric)) |>
  prcomp(scale. = TRUE)
```

As is typical with models in R, the result, `crime.pca` of `prcomp()` is an object of class `"prcomp"`,
a list of components, and there are a variety of methods for `"prcomp"` objects. Among the simplest
is `summary()`, which gives the contributions of each component to the total variance in the dataset.

```{r crime-pca-summary}
summary(crime.pca) |> print(digits=2)
```

The object, `crime.pca` returned by `prcomp()` is a list of the following the following elements:
```{r crime-pca-components}
names(crime.pca)
```

Of these, for $n$ observations and $p$ variables,

* `sdev` is the length $p$ vector of the standard deviations of the principal components (i.e., the square roots $\sqrt{\lambda_i}$ of the eigenvalues of the covariance/correlation matrix);
* `rotation` is the $p \times p$ matrix of weights or **loadings** of the variables on the components; the columns are the eigenvectors of the covariance or correlation matrix of the data;
* `x` is the $n \times p$ matrix of **scores** for the observations on the components, the result of multiplying (rotating) the data matrix by the loadings. These are uncorrelated, so `cov(x)` is a $p \times p$ diagonal matrix whose diagonal elements are the eigenvalues $\lambda_i$ = `sdev^2`.

### Visualizing variance proportions: screeplots

For a high-D dataset, such as the crime data in seven dimensions, a natural question is how much of the
variation in the data can be captured in 1D, 2D, 3D, ... summaries and views. This is answered by
considering the proportions of variance accounted by each of the dimensions, or their cumulative values.
The components returned by various PCA methods have (confusingly) different names, so
`broom::tidy()` provides methods to unify extraction of these values.

```{r crime-pca-tidy}
(crime.eig <- crime.pca |> 
  broom::tidy(matrix = "eigenvalues"))
```

Then, a simple visualization is a plot of the proportion of variance for each component (or cumulative proportion)
against the component number, usually called a **screeplot**. The idea, introduced by @Cattell1966, is that
after the largest, dominant components, the remainder should resemble the rubble, or scree formed by rocks falling
from a cliff. 

From this plot, imagine
drawing a straight line through the plotted eigenvalues, starting with the largest one. The typical rough guidance is that the last point to fall on this line represents the last component to extract, the idea being that beyond this, the amount of additional variance explained is non-meaningful. Another rule of thumb is to choose the number
of components to extract a desired proportion of total variance, usually in the range of 80 - 90%.

`stats::plot(crime.pca)` would give a bar plot of the variances of the components, however `ggbiplot::ggscreeplot()` gives nicer and more flexible displays as shown in @fig-crime-ggscreeplot.

```{r}
#| label: fig-crime-ggscreeplot
#| fig-height: 4
#| out-width: "100%"
#| fig-cap: "Screeplots for the PCA of the crime data. The left panel shows the traditional version, plotting variance proportions against component number, with linear guideline for the scree rule of thumb. The right panel plots cumulative proportions, showing cutoffs of 80%, 90%."
p1 <- ggscreeplot(crime.pca) +
  stat_smooth(data = crime.eig |> filter(PC>=4), 
              aes(x=PC, y=percent), method = "lm", 
              se = FALSE,
              fullrange = TRUE) +
  theme_bw(base_size = 14)

p2 <- ggscreeplot(crime.pca, type = "cev") +
  geom_hline(yintercept = c(0.8, 0.9), color = "blue") +
  theme_bw(base_size = 14)

p1 + p2
```

From this we might conclude that four components are necessary to satisfy the scree criterion or to
account for 90% of the total variation in these crime statistics. However two components, giving
76.5%, might be enough juice to tell a reasonable story.

### Visualizing PCA scores and variable vectors

To see and attempt to understand PCA results, it is useful to plot both the scores for the observations
on a few of the largest components and also the loadings or variable vectors that give the weights
for the variables in determining the principal components.

In @sec-biplot I discuss the biplot technique that plots both in a single display. However,
I do this directly here, using tidy processing to explain what is going on in PCA
and in these graphical displays.

#### Scores {.unnumbered}
The (uncorrelated) principal component scores can be extracted as `crime.pca$x` or using `purrr::pluck("x")`. As noted above, these are uncorrelated and have variances
equal to the eigenvalues of the correlation matrix.

```{r scores}
scores <- crime.pca |> purrr::pluck("x") 
cov(scores) |> zapsmall()
```

For plotting, it is more convenient to use `broom::augment()` which 
extracts the scores (named `.fittedPC*`)
and appends these to the variables in the dataset.

```{r}
crime.pca |>
  broom::augment(crime) |> head()
```

Then, we can use `ggplot()` to plot any pair of components.
To aid interpretation, I label the points by their state abbreviation and color them
by `region` of the U.S.. A geometric interpretation of the plot requires 
an aspect ratio of 1.0 (via `coord_fixed()`)
so that a unit distance on the horizontal axis is the
same length as a unit distance on the vertical.
To demonstrate that the components are uncorrelated, I also added their data
ellipse.

```{r}
#| label: fig-crime-scores-plot12
#| out-width: "100%"
#| fig-cap: "Plot of component scores on the first two principal components for the `crime` data. States are colored by `region`."
crime.pca |>
  broom::augment(crime) |> # add original dataset back in
  ggplot(aes(.fittedPC1, .fittedPC2, color = region)) + 
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_point(size = 1.5) +
  geom_text(aes(label = st), nudge_x = 0.2) +
  stat_ellipse(color = "grey") +
  coord_fixed() +
  labs(x = "PC Dimension 1", y = "PC Dimnension 2") +
  theme_minimal(base_size = 14) +
  theme(legend.position = "top") 
```

To interpret such plots, it is useful consider the observations that are a high
and low on each of the axes as well as other information, such as region here,
and ask how these differ on the crime statistics.
The first component, PC1, contrasts Nevada and California with North Dakota, South Dakota
and West Virginia. The second component has most of the southern states on the low end
and Massachusetts, Rhode Island and Hawaii on the high end. However, interpretation is
easier when we also consider how the various crimes contribute to these dimensions.

When, as here, there
are more than two components that seem important in the scree plot,
we could obviously go further and plot other pairs.

#### Variable vectors {.unnumbered}

You can extract the variable loadings using either `crime.pca$rotation` or
`purrr::pluck("rotation")`, similar to what I did with the scores.

```{r rotation}
crime.pca |> purrr::pluck("rotation")
```

But note something important in this output: All of the weights for the first component are negative. In PCA, the directions of the eigenvectors are completely arbitrary, in the sense that the vector $-\mathbf{v}_i$ gives the same linear combination as $\mathbf{v}_i$,
but with its' sign reversed. For interpretation, it is useful (and usually recommended) to reflect the loadings to a positive orientation by multiplying them by -1.

To reflect the PCA loadings and get them into a convenient format for plotting with `ggplot()`, it is necessary to do a bit of processing, including making the `row.names()` into an explicit variable for the purpose of labeling.

```{r vectors}
vectors <- crime.pca |> 
  purrr::pluck("rotation") |>
  as.data.frame() |>
  mutate(PC1 = -1 * PC1, PC2 = -1 * PC2) |>      # reflect axes
  tibble::rownames_to_column(var = "label") 

vectors[, 1:3]
```

Then, I plot these using `geom_segment()`, taking some care to use arrows
from the origin with a nice shape and add `geom_text()` labels for the variables positioned slightly to the right. Again, `coord_fixed()` ensures equal scales for the axes, which is important because we want to interpret the angles between the variable vectors and the 
PCA coordinate axes.

```{r}
#| label: fig-crime-vectors
#| out-width: "80%"
#| fig-cap: "Plot of component loadings the first two principal components for the `crime` data. These are interpreted as the contributions of the variables to the components."
arrow_style <- arrow(
  angle = 20, ends = "first", type = "closed", 
  length = grid::unit(8, "pt")
)

vectors |>
  ggplot(aes(PC1, PC2)) +
  geom_hline(yintercept = 0) +
  geom_vline(xintercept = 0) +
  geom_segment(xend = 0, yend = 0, 
               linewidth = 1, 
               arrow = arrow_style,
               color = "brown") +
  geom_text(aes(label = label), 
            size = 5,
            hjust = "outward",
            nudge_x = 0.05, 
            color = "brown") +
  xlim(-0.4, 0.9) + 
  ylim(-0.8, 0.8) +
  coord_fixed() + 
  theme_minimal(base_size = 14)
```

What is shown in @fig-crime-vectors has the following interpretations:

(1) the lengths of the variable vectors, $||\mathbf{v}_i|| = \sqrt{\Sigma_{j = 1:2} \; v_{ij}^2}$ give the proportion of variance of each variable accounted for in a two-dimensional display.

(2) the value, $v_{ij}$, of the vector for variable $\mathbf{x}_i$ on component $j$ gives
the correlation of that variable with the $j$th principal component.

(3) the cosine of the angle between two variable vectors, $\mathbf{v}_i$ and $\mathbf{v}_j$
gives the approximation of the correlation between $\mathbf{x}_i$ and $\mathbf{x}_j$
that is shown in this space. This means that two variable vectors that point in the same direction are highly correlated, while variable vectors at right angles are approximately uncorrelated.

To illustrate point (1), the following indicates that almost 70% of the variance of
`murder` is represented in the the 2D plot shown in @fig-crime-scores-plot12, but only
40% of the variance of `robbery` is captured.

```{r}
vectors |> select(label, PC1, PC2) |> 
  mutate(length = sqrt(PC1^2 + PC2^2))
```




## Biplots {#sec-biplot}

The biplot is a simple and powerful idea that came from the recognition that
you can overlay a plot of observation scores in a principal components analysis
with the information of the variable loadings (weights) to give a simultaneous display
that is easy to interpret. In this sense, a biplot is generalization of a scatterplot,
projecting from data space to PCA space, where the observations are shown by points, as in the plots of
component scores in @fig-crime-scores-plot12, but with the 
variables also shown by vectors (or scaled linear axes aligned with those vectors).

The idea of the biplot was introduced by Ruben Gabriel [-@Gabriel:71;-@Gabriel:81] and later expanded in scope by @GowerHand:96. The book by @Greenacre:2010:biplots gives a practical overview
of the many variety of biplots and @Gower-etal:2011 provide a full treatment ...

Biplot methodolgy is far more general than I cover here. Categorical variables can be incorporated in PCA
using category level points. 
Two-way frequency tables of categorical variables
can be analysed using _correspondence analysis_, which is similar to
PCA, but designed to account for the maximum amount of the $\chi^2$ statistic
for association; _multiple correspondence analysis_ extends this to
method to multi-way tables [@FriendlyMeyer:2016:DDAR;@Greenacre:84].



### Constructing a biplot

The biplot is constructed by using the singular value decomposition (SVD) to obtain a low-rank approximation to the data matrix $\mathbf{X}_{n \times p}$ (centered, and optionally scaled to unit variances)
whose $n$ rows are the observations and whose $p$ columns are the variables. 


```{r}
#| label: svd-diagram
#| echo: false
#| out-width: "80%"
#| fig-cap: "The singular value decomposition expresses a data matrix **X** as the product of a matrix **U** of observation scores, a diagonal matrix **Lambda** of singular values and a matrix **V** of variable weights. **TODO**: Re-draw to fix notation. "
knitr::include_graphics("images/SVD-eqn.jpg")
```

Using the SVD, the matrix $\mathbf{X}$, of rank $r \le p$
can be expressed _exactly_ as:
$$
\mathbf{X} = \mathbf{U} \mathbf{\Lambda} \mathbf{V}'
                 = \sum_i^r \lambda_i \mathbf{u}_i \mathbf{v}_i' \; ,
$$          

where 

   * $\mathbf{U}$ is an $n \times r$ orthonormal matrix of uncorrelated observation scores; these are also the 
         eigenvectors of $\mathbf{X} \mathbf{X}'$,
   * $\mathbf{\Lambda}$ is an $r \times r$ diagonal matrix of singular values, 
         $\lambda_1 \ge \lambda_2 \ge \cdots \lambda_r$, which are also the square roots
         of the eigenvalues of $\mathbf{X} \mathbf{X}'$. 
   * $\mathbf{V}$ is an $r \times p$ orthonormal matrix of observation scores and also the 
         eigenvectors of $\mathbf{X}' \mathbf{X}$.

Then, a rank 2 (or 3) PCA approximation $\widehat{\mathbf{X}}$ to the data matrix used in the biplot can be obtained from the first 2 (or 3)
singular values $\lambda_i$ and the corresponding $\mathbf{u}_i, \mathbf{v}_i$ as:

$$
\mathbf{X} \approx \widehat{\mathbf{X}} = \lambda_1 \mathbf{u}_1 \mathbf{v}_1' + \lambda_2 \mathbf{u}_2 \mathbf{v}_2' \; .
$$

The variance of $\mathbf{X}$ accounted for by each term is $\lambda_i^2$.

A biplot is then obtained by overlaying two scatterplots that share a common set of axes and have a between-set scalar 
product interpretation. Typically, the observations (rows of $\mathbf{X}$) are represented as points
and the variables (columns of $\mathbf{X}$) are represented as vectors from the origin.

The \code{scale} factor, $\alpha$ allows the variances of the components to be apportioned between the
row points and column vectors, with different interpretations, by representing the approximation
$\widehat{\mathbf{X}}$ as the product of two matrices,

$$
\widehat{\mathbf{X}} = (\mathbf{U} \mathbf{\Lambda}^\alpha) (\mathbf{\Lambda}^{1-\alpha} \mathbf{V}') = \mathbf{A} \mathbf{B}'
$$
This notation uses a little math trick involving a power, $0 \le \alpha \le 1$:
When $\alpha = 1$, $\mathbf{\Lambda}^\alpha = \mathbf{\Lambda}^1  =\mathbf{\Lambda}$,
and $\mathbf{\Lambda}^{1-\alpha} = \mathbf{\Lambda}^0  =\mathbf{I}$.
$\alpha = 1/2$ gives the diagonal matrix $\mathbf{\Lambda}^{1/2}$ whose elements are the square roots of the singular values.

The choice $\alpha = 1$ assigns the singular values totally to the left factor;
then, the angle between two variable vectors, reflecting the inner product 
$\mathbf{x}_j^T, \mathbf{x}_{j'}$ approximates their correlation or covariance,
and the distance between the points approximates their Mahalanobis distances.
$\alpha = 0$ gives a distance interpretation to the column display.
$\alpha = 1/2$ gives a symmetrically scaled biplot.
*TODO**: Explain this better.

When the singular values are assigned totally to the left or to the right factor, the resultant 
coordinates are called _principal coordinates_ and the sum of squared coordinates
on each dimension equal the corresponding singular value.
The other matrix, to which no part of the singular 
values is assigned, contains the so-called _standard coordinates_ and have sum of squared
values equal to 1.0. 



### Biplots in R

There are a large number of R packages providing biplots. The most basic, `stats::biplot()`, provides methods for `"prcomp"` and `"princomp"` objects.

**TODO**: Mention **factoextra** package, `fviz()`, `fviz_pca_biplot()`, ... giving `ggplot2` graphics. Also mention **adegraphics** package

Here, I use the **ggbiplot** package, which aims to provide a simple interface to biplots within the `ggplot2` framework.

### Example

A basic biplot of the `crime` data, using standardized principal components and labeling the observation by their state abbreviation is shown in @fig-crime-biplot1.
The correlation circle indicates that these components are uncorrelated and have
equal variance in the display.
```{r}
#| label: fig-crime-biplot1
#| out-width: "80%"
#| fig-cap: "Basic biplot of the crime data. ..."
crime.pca <- reflect(crime.pca) # reflect the axes

ggbiplot(crime.pca,
   obs.scale = 1, var.scale = 1,
   labels = crime$st ,
   circle = TRUE,
   varname.size = 4,
   varname.color = "brown") +
  theme_minimal(base_size = 14) 
```

In this dataset the states are grouped by region and we saw some differences among regions in the plot (@fig-crime-scores-plot12) of component scores.
`ggbiplot()` provides options to include a `groups =` variable, used to
color the observation points and also to draw their data ellipses, facilitating interpretation.
```{r}
#| label: fig-crime-biplot2
#| out-width: "80%"
#| fig-cap: "Enhanced biplot of the crime data, grouping the states by region and adding data ellipses."
ggbiplot(crime.pca,
   obs.scale = 1, var.scale = 1,
   groups = crime$region,
   labels = crime$st,
   labels.size = 4,
   var.factor = 1.4,
   ellipse = TRUE, ellipse.level = 0.5, ellipse.alpha = 0.1,
   circle = TRUE,
   varname.size = 4,
   varname.color = "black") +
  labs(fill = "Region", color = "Region") +
  theme_minimal(base_size = 14) +
  theme(legend.direction = 'horizontal', legend.position = 'top')
```

This plot provides what is necessary to interpret the nature of the components and also the variation of the states in relation to these. In this, the data ellipses for the regions
provide a visual summary that aids interpretation.

* From the variable vectors, it seems that PC1, having all positive and nearly equal loadings, reflects a total or overall index of crimes. Nevada, California, New York and Florida are highest on this, while North Dakota, South Dakota and West Virginia are lowest.

* The second component, PC2, shows a contrast between crimes against persons (murder, assault, rape) at the top and property crimes (auto theft, larceny) at the bottom. Nearly all the Southern states are high on personal crimes; states in the North East are generally higher
on property crimes.

* Western states tend to be somewhat higher on overall crime rate, while North Central are lower on average. In these states there is not much variation in the relative proportions of personal vs. property crimes.

Moreover, in this biplot you can interpret the the value for a particular state on a given crime by considering its projection on the variable vector, where the origin corresponds to the mean, positions along the vector have greater than average values on that crime, and the opposite direction have lower than average values. For example, Massachusetts has the highest value on auto theft, but a value less than the mean. Louisiana and South Carolina on the other hand are highest in the rate of murder and slightly less than average on auto theft.

These 2D plots account for only 76.5% of the total variance of crimes, so it is useful to also examine the third principal component, which accounts for an additional 10.4%.
The `choices =` option controls which dimensions are plotted.

```{r}
#| label: fig-crime-biplot3
#| out-width: "80%"
#| fig-cap: "Biplot of dimensions 1 & 3 of the crime data."
ggbiplot(crime.pca,
         choices = c(1,3),
         obs.scale = 1, var.scale = 1,
         groups = crime$region,
         labels = crime$st,
         labels.size = 4,
         var.factor = 2,
         ellipse = TRUE, ellipse.level = 0.5, ellipse.alpha = 0.1,
         circle = TRUE,
         varname.size = 4,
         varname.color = "black") +
  labs(fill = "Region", color = "Region") +
  theme_minimal(base_size = 14) +
  theme(legend.direction = 'horizontal', legend.position = 'top')
```

Dimension 3 in @fig-crime-biplot3 is more subtle. One interpretation is a contrast between
larceny, which is a simple theft and robbery, which involves stealing something from a person
and is considered a more serious crime with an element of possible violence.
In this plot, murder has a relatively short variable vector, so does not contribute
very much to differences among the states.

## Application: Variable ordering for data displays

In many multivariate data displays, such as scatterplot matrices, parallel coordinate plots and others
reviewed in @sec-multivariate_plots,
the order of different variables might seem arbitrary. They might appear in alphabetic order, or more often in the order they appear in your dataset, for example when you use `pairs(mydata)`.
Yet, the principle of _effect ordering_ (@FriendlyKwan:03:effect) for variables says you should try to arrange the variables so that adjacent ones are as similar as possible.
**TODO**: Mention seriation as the general topic.

For example, the `mtcars` dataset contains data on 32 automobiles from the 1974 U.S. magazine
_Motor Trend_ and consists of fuel comsumption (`mpg`) and 10 aspects of automobile
design (`cyl`: number of cyliners; `hp`: horsepower, `wt`: weight) and performance
(`qsec`: time to drive a quarter-mile). What can we see from a simple `corrplot()` of their
correlations?


```{r}
#| label: fig-mtcars-corrplot-varorder
#| fig-width: 8
#| fig-height: 8
#| out-width: "75%"
#| fig-cap: "Corrplot of `mtcars` data, with the variables in the order they appear in the dataset."
data(mtcars)
library(corrplot)
R <- cor(mtcars)
corrplot(R, 
         method = 'ellipse',
         title = "Dataset variable order",
         tl.srt = 0, tl.col = "black", tl.pos = 'd',
         mar = c(0,0,1,0))
```


In this display you can scan the rows and columns to "look up" the sign and approximate magnitude of a given correlation; for example, the correlation between `mpg` and `cyl` appears to be about -0.9,
while that between `mpg` and `gear` is about 0.5. Of course, you could print the correlation matrix to find the actual values (-0.86 and 0.48 respectively):

```{r mtcars-cor}
print(floor(100*R))
```

Because the angles between variable vectors in the biplot reflect their correlations, @FriendlyKwan:03:effect defined **principal component variable ordering** as the order of angles,
$a_i$ of the first two eigenvectors, $\mathbf{v}_1, \mathbf{v}_2$ around the unit circle. These values are calculated going counter-clockwise from the 12:00 position as:

$$
a_i = 
  \begin{cases}
    \tan^{-1} (v_{i2}/v_{i1}), & \text{if $v_{i1}>0$;}
     \newline
    \tan^{-1} (v_{i2}/v_{i1}) + \pi, & \text{otherwise.}
  \end{cases}     
$$
(read $\tan^{-1}(x)$ as "the angle whose tangent is $x$".)

For the `mtcars` data the biplot in @fig-mtcars-biplot accounts for 84% of the total variance
so a 2D representation is fairly good.
The plotshows the variables as widely dispersed. There is a collection at the left of positively correlated variables and another positively correlated set at the right.

```{r}
#| label: fig-mtcars-biplot
#| fig-width: 8
#| fig-height: 8
#| out-width: "70%"
#| fig-cap: "Biplot of the `mtcars` data ..."
mtcars.pca <- prcomp(mtcars, scale. = TRUE)
ggbiplot(mtcars.pca,
         circle = TRUE,
         point.size = 2.5,
         varname.size = 6,
         varname.color = "brown") +
  theme_minimal(base_size = 14) 
```

In `corrplot()` principal component variable ordering is implemented using the `order = "AOE"` option. There are a variety of other methods based on hierarchical cluster analysis described in the 
[package vignette](https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html).

@fig-mtcars-corrplot-pcaorder shows the result. A nice feature of `corrplot()` is the ability to manually highlight blocks of variables that have a similar pattern of signs by outlining them with
rectangles. From the biplot, the two main clusters of positively correlated variables seemed clear,
and are outlined in the plot using `corrplot::corrRect()`. What became clear in the corrplot is that `qsec`, the time to drive a quarter-mile from a dead start didn't fit this pattern, so I highlighted it
separately.

```{r}
#| label: fig-mtcars-corrplot-pcaorder
#| fig-width: 8
#| fig-height: 8
#| out-width: "75%"
#| fig-cap: "Corrplot of `mtcars` data, with the variables ordered according to the variable vectors in the biplot."
corrplot(R, 
         method = 'ellipse', 
         order = "AOE",
         title = "PCA variable order",
         tl.srt = 0, tl.col = "black", tl.pos = 'd',
         mar = c(0,0,1,0)) |>
  corrRect(c(1, 6, 7, 11))
```

But wait, there is something else to be seen in @fig-mtcars-corrplot-pcaorder.
Can you see one cell that doesn't fit with the rest?

Yes, the correlation of number of forward gears (`gear`) and number of carburators (`carb`)
in the upper left and lower right corners is moderately positive (0.27) while all the others
in their off-diagonal blocks are negative. 

## Elliptical insights: Outlier detection

The data ellipse (@sec-data-ellipse), or ellipsoid in more than 2D is fundamental in regression. But also,
as Pearson showed, it is key to understanding principal components analysis, where the principal component directions are simply
the axes of the ellipsoid of the data. As such, observations that are unusual in data space may not stand out
in univariate views of the variables, but will stand out in principal component space, usually on the _smallest_ dimension.

As an illustration, I created a dataset of $n = 100$ observations
with a linear relation, $y = x + \mathcal{N}(0, 1)$ and then
added two discrepant points at (1.5, -1.5), (-1.5, 1.5).

```{r}
set.seed(123345)
x <- c(rnorm(100),             1.5, -1.5)
y <- c(x[1:100] + rnorm(100), -1.5, 1.5)
```

When these are plotted with a data ellipse in @fig-outlier-demo (left), you can see
the discrepant points labeled 101 and 102, but they do not stand out as unusual on
either $x$ or $y$. The transformation to from data space to principal components space,
shown in @fig-outlier-demo (right),
is simply a rotation of $(x, y)$ to a space whose coordinate axes are the major and minor axes of the data ellipse, $(PC_1, PC_2)$. In this view, the additional points appear a univariate outliers on the smallest dimension, $PC_2$.

```{r}
#| label: fig-outlier-demo
#| echo: false
#| out-width: "100%"
#| fig-cap: "**Outlier demonstration**: The left panel shows the original data and highlights the two discrepant points, which do not appear to be unusual on either x or y. The right panel shows the data rotated to principal components, where the labeled points stand out on the smallest PCA dimension."
knitr::include_graphics("images/outlier-demo.png")
```

To see this more clearly, @fig-outlier-animation shows an animation of the rotation from data space to PCA space. This uses `heplots::interpPlot()` ...

::: {#fig-outlier-animation}
<div align="center">
  <iframe width="480" height="480" src="images/outlier-demo.gif"></iframe>
</div>

Animation of rotation from data space to PCA space.
:::
      
      

