---
title: "Colorizing text - Luminance-based coloring"
author: "Michael Friendly"
date: today
format:
  html:
    html-math-method: mathjax
  pdf:
    keep-tex: true
    latex-tinytex: true
---

```{r include=FALSE}
#source("R/common.R")
knitr::opts_chunk$set(error = TRUE)
```

## Printing text in color in HTML and LaTeX

In the Quarto  book I'm writing when I refer to colors, used in graphs in the text, or in figure captions,
I want to print their names in their actual color to give a direct impression of the color, like "red" shown in red,
"blue" shown in blue. This is similar to the use of direct labels in graphs, which are perceptually bound
to what is portrayed, rather than an indirect legend which takes more cognitive energy.

But, for text display, if the color is light, it doesn't show up well on
a white background. Alternatively I could color the background, but if the color is dark, black text for the color name doesn't
show up well. Here are some colors for testing these ideas and solutions. 

```{r test-colors}
test_colors <- c("red", "blue", "green",
                 "white", "black", "gray",
                 "pink", "yellow", "darkgreen",
                 "orange", "purple")
```

RStudio does a reasonable job of this in editor windows, using various shades of gray for the text on a colored background
of the named color. Here's what this looks like in a `.qmd` document

![test-colors](images/test_colors.png)


My question was, "How can I achieve this in a Quarto document to be rendered in either HTML or PDF?"
The immediate answer was to define a function, `colorize(text, color)` that could be used inline
in text.


### Using `colorize()` - Original approach

Define a function `colorize(text, color)` to print `text` in `color`. If `color` is missing, assume `text` is the color.
This uses `knitr::is_*` functions to decide whether to use HTML or LaTeX coding to achieve this.

```{r colorize}
colorize <- function(text, color) {
  if (missing(color)) color <- text
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}{%s}", color, text)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='color: %s;'>%s</span>", color, text)
  } else text      # Fallback for other formats
}
```

Here's what this gives, trying out both forms, where `color` is supplied or missing:

`r colorize("Gentoo", "orange")` and  `r colorize("Adelie", "purple")` and  `r colorize("Chinstrap", "darkgreen")` are Penguins.

This plot has `r colorize("red")` points, `r colorize("blue")` points, `r colorize("green")` points, which are nice.
Other colors used in the plot are `r colorize("yellow")`, `r colorize("pink")`, `r colorize("gray")` and `r colorize("black")`.

As you can see, `r colorize("yellow")` and `r colorize("pink")` are illegible.

### Using `colorize_bg()` - Background approach

For legibility, it may work better to use the supplied color as background color, rather than text color.
Here's an analogous function to do this. In the HTML output, it uses `<span style='background-color:` rather than
`<span style='color:` and similarly for LaTeX, where it uses `\colorbox{}` rather than `\textcolor{}`.

```{r colorize-bg}
colorize_bg <- function(text, bgcolor) {
  if (missing(bgcolor)) bgcolor <- text
  if (knitr::is_latex_output()) {
    sprintf("\\colorbox{%s}{%s}", bgcolor, text)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='background-color: %s;'>%s</span>", bgcolor, text)
  } else {
    text # Fallback for other formats
  }
}
```

Trying this out gives:

`r colorize_bg("Gentoo", "orange")` and  `r colorize_bg("Adelie", "purple")` and  `r colorize_bg("Chinstrap", "darkgreen")` are Penguins.

This plot has `r colorize_bg("red")` points, `r colorize_bg("blue")` points, `r colorize_bg("green")` points, which are nice.
Other colors used in the plot are `r colorize_bg("yellow")`, `r colorize_bg("pink")`, `r colorize_bg("gray")` and `r colorize_bg("black")`.

As you can see, `r colorize_bg("blue")` and `r colorize_bg("black")` are illegible.

## Solution: `colorize2()` with luminance-based text color

The key is to calculate the luminance of the background color and choose an appropriate gray shade for the text.
I'll use relative luminance (similar to WCAG standards) to determine if a color is "light" or "dark".

```{r colorize2}
library(colorspace)

colorize2 <- function(text, color) {
  if (missing(color)) color <- text
  # grey -> gray, because xcolor doesn't recognize this
  if (color == "grey") color <- "gray"
  
  # Convert color to RGB and then to relative luminance
  # Using sRGB color space for accurate luminance calculation
  rgb_vals <- col2rgb(color)[, 1] / 255
  
  # Apply gamma correction for sRGB
  rgb_linear <- ifelse(rgb_vals <= 0.03928,
                       rgb_vals / 12.92,
                       ((rgb_vals + 0.055) / 1.055)^2.4)
  
  # Calculate relative luminance (ITU-R BT.709)
  luminance <- 0.2126 * rgb_linear[1] + 
               0.7152 * rgb_linear[2] + 
               0.0722 * rgb_linear[3]
  
  # Choose text color based on luminance
  # Adjusted thresholds for better contrast
  # LaTeX uses black!X notation where X is percentage of black (0-100)
  if (luminance > 0.65) {
    # Very light backgrounds: use very dark gray
    text_color_latex <- "black!90"  # 90% black
    text_color_html <- "#1a1a1a"
  } else if (luminance > 0.45) {
    # Light-medium backgrounds: use dark gray  
    text_color_latex <- "black!80"  # 80% black
    text_color_html <- "#333333"
  } else if (luminance > 0.25) {
    # Medium-dark backgrounds: use light gray
    text_color_latex <- "black!20"  # 20% black (80% white)
    text_color_html <- "#cccccc"
  } else {
    # Very dark backgrounds: use very light gray
    text_color_latex <- "black!10"  # 10% black (90% white)
    text_color_html <- "#e6e6e6"
  }
  
  # Generate output based on format
  if (knitr::is_latex_output()) {
    sprintf("\\colorbox{%s}{\\textcolor{%s}{%s}}", color, text_color_latex, text)
  } else if (knitr::is_html_output()) {
    sprintf("<span style='background-color: %s; color: %s;'>%s</span>", 
            color, text_color_html, text)
  } else {
    text  # Fallback for other formats
  }
}
```

### Test `colorize2()` with all colors

Let's try the new function with all test colors:

`r colorize2("Gentoo", "orange")` and  `r colorize2("Adelie", "purple")` and  `r colorize2("Chinstrap", "darkgreen")` are Penguins.

This plot has `r colorize2("red")` points, `r colorize2("blue")` points, `r colorize2("green")` points, which are nice.
Other colors used in the plot are `r colorize2("yellow")`, `r colorize2("pink")`, `r colorize2("gray")`, `r colorize2("white")` and `r colorize2("black")`.

All colors should now be legible!

### Diagnostic: Show luminance values

Let's see the calculated luminance for each test color:

```{r luminance-check}
library(colorspace)

# Function to calculate luminance
get_luminance <- function(color) {
  rgb_vals <- col2rgb(color)[, 1] / 255
  rgb_linear <- ifelse(rgb_vals <= 0.03928,
                       rgb_vals / 12.92,
                       ((rgb_vals + 0.055) / 1.055)^2.4)
  luminance <- 0.2126 * rgb_linear[1] + 
               0.7152 * rgb_linear[2] + 
               0.0722 * rgb_linear[3]
  return(luminance)
}

# Calculate luminance for all test colors
luminance_df <- data.frame(
  color = test_colors,
  luminance = round(sapply(test_colors, get_luminance), 3),
  text_color_html = sapply(test_colors, function(col) {
    lum <- get_luminance(col)
    if (lum > 0.65) "#1a1a1a"
    else if (lum > 0.45) "#333333"
    else if (lum > 0.25) "#cccccc"
    else "#e6e6e6"
  }),
  text_color_latex = sapply(test_colors, function(col) {
    lum <- get_luminance(col)
    if (lum > 0.65) "black!90"
    else if (lum > 0.45) "black!80"
    else if (lum > 0.25) "black!20"
    else "black!10"
  })
)

print(luminance_df)
```

But, in this, I was surprised that I could not find function in the `colorspace` package to do `this`get_numinance()` more simply. Searching on the web, I found `chroma::lumkinance()` but this is not available on CRAN, and I couldn't take this on as a dependence.

### Complete test of all colors

Here's a comprehensive test showing all colors with their appropriate contrast:

```{r results='asis'}
cat("Colors: ", 
    paste(sapply(test_colors, colorize2), collapse = ", "))
```

## Calculating luminance

The `colorize2()` function uses a somewhat complex calculation to determine the luminance of a color. This section explains what's happening and whether there are simpler alternatives.

### What the function does

The luminance calculation in `colorize2()` follows the WCAG (Web Content Accessibility Guidelines) standard for determining contrast ratios. Here's what each step accomplishes:

1. **Convert to RGB values (0-1 scale)**: `col2rgb()` gets RGB values in 0-255 range, which we normalize to 0-1.

2. **Apply gamma correction**: The `ifelse()` statement converts from sRGB (the color space used by monitors) to linear RGB. This is necessary because sRGB uses a gamma encoding that makes the relationship between color values and light intensity non-linear. The formulas used here are from the sRGB specification.

3. **Calculate relative luminance**: The weighted sum (0.2126×R + 0.7152×G + 0.0722×B) reflects how human vision perceives brightness. We're much more sensitive to green light than blue, which is why green has the highest weight. This formula comes from the ITU-R BT.709 standard for HDTV.

The result is a value between 0 (black) and 1 (white) that represents how bright the color appears to human perception. This is used to determine whether dark or light text will be more readable on that background.

### Why this approach?

This relative luminance calculation is the gold standard for accessibility because it accurately predicts whether text will be readable on a given background. It's the same formula used by all WCAG contrast checkers. The gamma correction step is particularly important—without it, colors like yellow and blue would not be properly distinguished (yellow would appear darker than it actually looks to our eyes).

### Simpler alternatives

While the calculation seems complex, there are simpler approaches that might work reasonably well for most cases:

#### Using HCL Lightness

The `colorspace` package provides HCL (Hue-Chroma-Luminance) color space, where the `L` component represents perceptual lightness:

```{r alternative-hcl, eval=FALSE}
library(colorspace)

colorize2_simple <- function(text, color) {
  if (missing(color)) color <- text
  if (color == "grey") color <- "gray"
  
  # Get HCL lightness (0-100 scale)
  hcl_L <- as(hex2RGB(color), "polarLUV")@coords[, "L"]
  
  # Choose text color based on lightness
  if (hcl_L > 70) {
    text_color_latex <- "black!80"
    text_color_html <- "#333333"
  } else if (hcl_L > 50) {
    text_color_latex <- "black!60"
    text_color_html <- "#666666"
  } else {
    text_color_latex <- "black!20"
    text_color_html <- "#cccccc"
  }
  
  # ... rest of function
}
```

This approach is simpler but has some drawbacks:

- **Different scale**: HCL L ranges from 0-100 rather than 0-1, so thresholds need adjustment
- **Not identical**: HCL lightness is perceptually uniform but doesn't exactly match physiological luminance
- **Still requires conversion**: You need to convert color names to hex first, then to RGB, then to HCL

#### Using simple RGB averaging

An even simpler approach is to just average the RGB values:

```{r alternative-simple, eval=FALSE}
# Very simple but less accurate
rgb_vals <- col2rgb(color)[, 1]
avg_brightness <- mean(rgb_vals)  # 0-255 scale

if (avg_brightness > 180) use_dark_text
else use_light_text
```

This works for many colors but fails for some important cases. For example, pure blue (RGB: 0, 0, 255) has an average of 85, suggesting light text would be appropriate. But blue is actually quite dark to our eyes, so you'd want light text. The proper luminance calculation accounts for this.

### Recommendation

For accessibility and maximum readability across all colors, the full relative luminance calculation used in `colorize2()` is worth the extra complexity. However, if you're primarily working with a limited palette of colors that you've tested, the HCL lightness approach provides a reasonable approximation with somewhat simpler code.

The key insight is that **not all RGB values contribute equally to perceived brightness**, and any simplified approach needs to account for this fact, either through proper weighting (as in relative luminance) or through a perceptually-based color space (as in HCL).
