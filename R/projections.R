#' ---
#' title: projections
#' ---

# idea from: Cook, Buja, Lee, Wickham, Grand Tours, Projection Pursuit, ...

vals <- c(0, 10)
X <- expand.grid(x1 = vals, x2=vals, x3=vals) |> as.matrix()

# project on just x1, x2 plane
P1 <- rbind(diag(2), c(0,0))
Y1 <- X %*% P1

# oblique projection
P2 <- matrix(c(0.71, 0.71, 0, -0.42, .42, 0.84), ncol=2)
Y2 <- X %*% P2

source("R/matrix2latex.R")

matrix2latex(X)
matrix2latex(P1)
matrix2latex(Y1)



pch <- rep(15:18, 2)
colors <- c("red", "blue", "darkgreen", "brown")
col <- rep(colors, each = 2)

data.frame(X, pch, col)

pairs(X, cex = 2, 
      pch = pch, col = col, 
      xlim = c(-1, 11), ylim = c(-1, 11))

op <- par(mar=c(4, 4, 1, 1)+.5)
plot(Y1, cex = 3, 
     pch = pch, col = col,
     xlab = expression(y[1]), ylab = expression(y[2]),
     xlim = c(-1, 11), ylim = c(-1, 11), cex.lab = 1.8)

plot(Y2, cex = 3, 
     pch = pch, col = col,
     xlab = expression(y[1]), ylab = expression(y[2]),
     xlim = c(-1, 15), ylim = c(-5, 14), cex.lab = 1.8)
par(op)

# draw X vectors in Y space
xlim <- ylim <- c(-1.1, 1.1)
axes.x <- c(-1, 1, NA, 0, 0)
axes.y <- c(0, 0, NA, -1, 1)
labs <- c(expression(x[1]), expression(x[2]), expression(x[3]))

op <- par(mar=c(4, 5, 1, 1)+.1)
plot(xlim, ylim, type = "n", asp=1,
     xlab = expression(y[1]), ylab = expression(y[2]),
     cex.lab = 1.8)
plotrix::draw.circle(0, 0, 1, 
                     col = adjustcolor("skyblue", alpha = 0.2))
lines(axes.x, axes.y, col = "grey")
matlib::vectors(P1, labels = labs, cex.lab = 1.8, lwd = 3)

plot(xlim, ylim, type = "n", asp=1,
     xlab = expression(y[1]), ylab = expression(y[2]),
     cex.lab = 1.8)
plotrix::draw.circle(0, 0, 1, 
                     col = adjustcolor("skyblue", alpha = 0.2))
lines(axes.x, axes.y, col = "grey")
matlib::vectors(P2, labels = labs, cex.lab = 1.8, lwd = 3)
par(op)

library(rgl)

# use spheres
open3d()
plot3d(X, type = "s", size = 2,  pch = pch, col = col)

# use pch symbols
open3d()
plot3d(X, type = "n")
pch3d(X, pch = pch, col = col)

# use sprites
# from: https://stackoverflow.com/questions/77958458/how-to-use-point-shapes-other-than-spheres-in-rgl/77958624
open3d()
plot3d(X, type = "n")
sprites3d(X, 
          shape = c(shade3d(spheres3d()),
                    shade3d(cube3d()),
                    shade3d(tetrahedron3d())
                    ),
          col = col
          )

open3d()
plot3d(X, type = "n")
shapes <- c(shade3d(spheres3d(), col = "red"),
            shade3d(cube3d(), col = "blue"),
            shade3d(tetrahedron3d(), col = "blue"),
            shade3d(octahedron3d(), col = "darkgreen"))

# sprites3d can only plot the same shapes at each location,
# so we'll call it 3 times
indx <- 1:8
for (i in 1:3) {
  j <- indx[indx %% 3 == i %% 3]
  sprites3d(X[j,,drop=FALSE], shape = shapes[i])
}


# Create a function to draw a cube
# -- generated by ChatGPT!; doesn't work
draw_cube <- function(side_length) {
  # Define the vertices of the cube
  vertices <- cbind(
    c(0, 0, 0, 0, 1, 1, 1, 1),
    c(0, 0, 1, 1, 0, 0, 1, 1),
    c(0, 1, 0, 1, 0, 1, 0, 1)
  ) * side_length
  
  # Connect the vertices to form the edges of the cube
  edges <- matrix(c(
    1, 2, 3, 4, 5, 6, 7, 8,
    1, 2, 4, 3, 5, 6, 8, 7,
    1, 3, 7, 5, 2, 4, 8, 6
  ), ncol = 3, byrow = TRUE)
  
  # Open an rgl window and plot the cube
  open3d()
  points3d(vertices)
  lines3d(vertices[edges[, 1], ], vertices[edges[, 2], ])
}

# Call the function to draw the cube with side length 10
draw_cube(10)


